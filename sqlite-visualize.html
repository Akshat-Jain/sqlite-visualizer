<!DOCTYPE html>
<html>
<head>
    <title>SQLite Physical Visualizer</title>
    <meta charset="UTF-8">
    <style>
        body { font-family: sans-serif; margin: 15px;}
        h1, h2 { border-bottom: 1px solid #eee; padding-bottom: 5px;}
        #fileInfo { margin-bottom: 15px; border: 1px solid #ccc; padding: 10px; background-color: #f9f9f9;}
        #pageMapContainer {
            width: 98%;
            height: 120px;
            border: 1px solid #ccc;
            overflow-x: auto;
            overflow-y: hidden;
            white-space: nowrap;
            margin-bottom: 5px; /* Reduced margin */
            position: relative;
            background-color: #fafafa;
        }
        /* --- Legend Styles --- */
        #pageMapLegend {
            margin-bottom: 20px;
            padding: 5px 10px;
            font-size: 0.85em;
            border: 1px solid #eee;
            background-color: #fdfdfd;
            display: flex; /* Arrange items horizontally */
            flex-wrap: wrap; /* Allow wrapping */
            gap: 15px; /* Space between items */
        }
        .legend-item {
            display: flex;
            align-items: center;
        }
        .legend-color-box {
            display: inline-block;
            width: 15px;
            height: 15px;
            margin-right: 5px;
            border: 1px solid #aaa;
            vertical-align: middle;
        }
        /* Make legend terms clickable */
        .legend-term {
            cursor: pointer;
            text-decoration: underline;
            text-decoration-style: dotted;
            text-decoration-color: #555;
            margin-left: 3px; /* Small space after color box */
        }
        .legend-term:hover {
            color: blue;
            text-decoration-color: blue;
        }

        .page { /* Page map box styles */
            display: inline-block;
            height: 100%;
            /* Base border - hover/selected changes this */
            border: 1px solid #ddd;
            border-right-color: #eee; /* Keep subtle visual separator */
            box-sizing: border-box;
            cursor: pointer;
            font-size: 9px;
            text-align: center;
            vertical-align: top;
            position: relative;
            overflow: hidden;
            color: #555;
            font-weight: bold;
        }
        /* This border setup might cause bottom border clipping on selected */
        .page:hover {
            border: 1px solid black; /* Consistent 1px border on hover */
            z-index: 10;
            filter: brightness(1.1);
        }
        .page.selected {
            border: 2px solid black; /* Thicker border for selected */
            /* Use outline for extra emphasis without affecting layout as much */
            outline: 1px solid orange;
            outline-offset: -2px; /* Draw outline slightly inside */
            filter: brightness(1.2);
            z-index: 20; /* Ensure selected is topmost */
        }

        /* --- Page Type Colors (Applied to page map and legend) --- */
        .page-table-internal, .legend-table-internal { background-color: #87CEFA; color: #005; }
        .page-index-internal, .legend-index-internal { background-color: #ADD8E6; color: #005;}
        .page-table-leaf, .legend-table-leaf { background-color: #90EE90; color: #050; }
        .page-index-leaf, .legend-index-leaf { background-color: #98FB98; color: #050; }
        .page-overflow, .legend-overflow { background-color: #FFA07A; color: #720; }
        .page-freelist-trunk, .legend-freelist-trunk { background-color: #FFD700; color: #640; }
        .page-freelist-leaf, .legend-freelist-leaf { background-color: #FFFFE0; color: #660; }
        .page-unknown, .legend-unknown { background-color: #D3D3D3; color: #333; }
        /* Add a default background for .page if needed, placed before specific types */
/*        .page { background-color: #D3D3D3; }*/

        /* SVG for links */
        #linkOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
        #linkOverlay line { stroke-width: 1.5; }
        #linkOverlay line title { pointer-events: auto; }

        /* --- Dialog Box Styles (Shared visual style) --- */
        .dialog-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); z-index: 999; }
        .dialog-box { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 80%; max-height: 85vh; background-color: #fff; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); z-index: 1000; overflow: hidden; }
        .dialog-header { display: flex; justify-content: space-between; align-items: center; padding: 10px 20px; background-color: #f0f0f0; border-bottom: 1px solid #ccc; border-top-left-radius: 8px; border-top-right-radius: 8px; }
        .dialog-header h2 { margin: 0; border: none; font-size: 1.2em; }
        .dialog-close-btn { background: none; border: none; font-size: 1.8em; line-height: 1; cursor: pointer; padding: 0 5px; color: #555; }
        .dialog-close-btn:hover { color: #000; }
        .dialog-content { padding: 15px 20px; overflow-y: auto; max-height: calc(85vh - 60px); /* Adjust based on header height */ font-family: monospace; font-size: 0.9em; line-height: 1.4; }

        /* --- Styles specific to Page Detail Dialog --- */
        #pageDetailDialog { max-width: 900px; } /* Wider dialog for page details */
        #pageDetailDialog .dialog-content h3 { margin-top: 15px; margin-bottom: 8px; border-bottom: 1px solid #eee; padding-bottom: 3px; font-size: 1.1em; }
        #pageDetailDialog .dialog-content dl { margin-left: 5px; margin-bottom: 15px; }
        #pageDetailDialog .dialog-content dt { font-weight: bold; color: #333; float: left; width: 200px; clear: left; margin-bottom: 5px; padding-right: 10px; }
        #pageDetailDialog .dialog-content dd { margin-left: 210px; margin-bottom: 5px; word-wrap: break-word; }
        #pageDetailDialog .dialog-content dl::after { content: ""; display: table; clear: both; }
        #pageDetailDialog .dialog-content pre { margin: 0 0 10px 0; padding: 10px; background-color: #eee; border: 1px dashed #ccc; border-radius: 4px; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word; }
        #pageDetailDialog .dialog-content .cell-detail-item { margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px dotted #ddd; }
        #pageDetailDialog .dialog-content .cell-detail-item:last-child { border-bottom: none; }
        #pageDetailDialog .dialog-content .data-dump { margin-top: 5px; padding-left: 15px; font-size: 0.9em; color: #444; white-space: pre; overflow-x: auto; }
        #pageDetailDialog .dialog-content .dump-content-container { margin-bottom: 5px; }
        #pageDetailDialog .dialog-content .show-more-btn { display: block; margin-left: 20px; margin-top: 3px; margin-bottom: 8px; padding: 2px 6px; font-size: 0.8em; cursor: pointer; font-family: sans-serif; }

        /* --- Styles specific to Legend Help Dialog --- */
         .legend-help-dialog { max-width: 600px; max-height: 70vh; }
         .legend-help-dialog .dialog-content { font-family: sans-serif; font-size: 0.95em; }
         .legend-help-dialog .dialog-content p { margin-bottom: 10px; line-height: 1.6; }
         .legend-help-dialog .dialog-content code,
         .legend-help-dialog .dialog-content pre { background-color: #eee; padding: 2px 5px; border-radius: 3px; font-family: monospace; font-size: 0.95em; }
         .legend-help-dialog .dialog-content pre { display: block; margin-top: 5px; padding: 10px; white-space: pre-wrap; word-wrap: break-word; }

        /* --- Visibility Control for Dialogs --- */
        /* Use separate overlays logically, even if visually identical */
        body.dialog-visible #pageDetailOverlay,
        body.dialog-visible #pageDetailDialog { display: block; }

        body.legend-dialog-visible #legendHelpOverlay,
        body.legend-dialog-visible #legendHelpDialog { display: block; }

        /* Ensure only one dialog type is visible */
        body.legend-dialog-visible #pageDetailDialog,
        body.legend-dialog-visible #pageDetailOverlay { display: none; }
        body.dialog-visible #legendHelpDialog,
        body.dialog-visible #legendHelpOverlay { display: none; }

    </style>
</head>
<body>

    <h1>SQLite Physical Structure Visualizer</h1>

    <input type="file" id="dbFile" accept=".db,.sqlite,.sqlite3">

    <div id="fileInfo">
        <h2>File Header Info</h2>
        <pre id="headerOutput">Upload a SQLite file to begin...</pre>
    </div>

    <h2>Page Map</h2>
    <p>(Colors indicate page type. Click a page for details.)</p>
    <!-- Legend -->
    <div id="pageMapLegend">
         <div class="legend-item">
             <span class="legend-color-box legend-table-leaf"></span>
             <span class="legend-term" data-term="table-leaf">Table Leaf</span>
         </div>
         <div class="legend-item">
             <span class="legend-color-box legend-index-leaf"></span>
             <span class="legend-term" data-term="index-leaf">Index Leaf</span>
         </div>
         <div class="legend-item">
            <span class="legend-color-box legend-table-internal"></span>
            <span class="legend-term" data-term="table-internal">Table Internal</span>
         </div>
         <div class="legend-item">
            <span class="legend-color-box legend-index-internal"></span>
            <span class="legend-term" data-term="index-internal">Index Internal</span>
         </div>
         <div class="legend-item">
            <span class="legend-color-box legend-overflow"></span>
            <span class="legend-term" data-term="overflow">Overflow</span>
         </div>
         <div class="legend-item">
            <span class="legend-color-box legend-freelist-trunk"></span>
            <span class="legend-term" data-term="freelist-trunk">Freelist Trunk</span>
         </div>
         <div class="legend-item">
            <span class="legend-color-box legend-freelist-leaf"></span>
            <span class="legend-term" data-term="freelist-leaf">Freelist Leaf</span>
         </div>
         <div class="legend-item">
            <span class="legend-color-box legend-unknown"></span>
            <span class="legend-term" data-term="unknown">Unknown/Other</span>
         </div>
    </div>
    <div id="pageMapContainer">
        <svg id="linkOverlay" width="100%" height="100%"></svg>
        <div id="pageMap"></div>
    </div>

    <!-- Page Detail Dialog Structure -->
    <div id="pageDetailOverlay" class="dialog-overlay"></div>
    <div id="pageDetailDialog" class="dialog-box">
        <div class="dialog-header">
            <h2 id="pageDetailTitle">Page Details</h2> <!-- Specific ID -->
            <button id="pageDetailCloseBtn" class="dialog-close-btn" aria-label="Close page details">×</button>
        </div>
        <div id="pageDetailContent" class="dialog-content">
            <p>Loading...</p>
        </div>
    </div>

    <!-- Legend Help Dialog Structure -->
    <div id="legendHelpOverlay" class="dialog-overlay"></div>
    <div id="legendHelpDialog" class="dialog-box legend-help-dialog">
        <div class="dialog-header">
            <h2 id="legendHelpTitle">Legend Explanation</h2>
            <button id="legendHelpCloseBtn" class="dialog-close-btn" aria-label="Close legend help">×</button>
        </div>
        <div id="legendHelpContent" class="dialog-content">
            <!-- Explanation will be injected here -->
        </div>
    </div>


    <script>
        // --- DOM Element References ---
        const fileInput = document.getElementById('dbFile');
        const headerOutput = document.getElementById('headerOutput');
        const pageMapDiv = document.getElementById('pageMap');
        const pageMapContainer = document.getElementById('pageMapContainer');
        const linkOverlay = document.getElementById('linkOverlay');
        // Page Detail Dialog elements
        const pageDetailOverlay = document.getElementById('pageDetailOverlay');
        const pageDetailDialog = document.getElementById('pageDetailDialog');
        const pageDetailTitle = document.getElementById('pageDetailTitle'); // Use correct ID
        const pageDetailContent = document.getElementById('pageDetailContent'); // Use correct ID
        const pageDetailCloseBtn = document.getElementById('pageDetailCloseBtn'); // Use correct ID
        // Legend Help Dialog elements
        const legendHelpOverlay = document.getElementById('legendHelpOverlay');
        const legendHelpDialog = document.getElementById('legendHelpDialog');
        const legendHelpTitle = document.getElementById('legendHelpTitle');
        const legendHelpContent = document.getElementById('legendHelpContent');
        const legendHelpCloseBtn = document.getElementById('legendHelpCloseBtn');
        const pageMapLegend = document.getElementById('pageMapLegend');


        // --- Global State ---
        let pageData = [];
        let pageSize = 0;
        let fileBuffer = null;
        let fileHeaderInfo = {};
        const DUMP_LENGTH = 32;

        // --- Legend Explanations Content ---
        const legendExplanations = {
            'table-leaf': { title: 'Table Leaf Page', explanation: 'Holds the actual data for table rows. When SQLite retrieves a row using its unique RowID (usually the primary key), it navigates the B-tree to land on one of these pages.', example: 'Imagine a phone book. This page contains the full entry for someone: \nName: Alice Smith, Phone: 555-1234, Address: 123 Main St.\nThe cell details would show something like:\n<code>Payload Size: 55, RowID: 101</code>' },
            'index-leaf': { title: 'Index Leaf Page', explanation: 'Holds the final entries for an index. It contains the indexed value(s) and points back to the RowID(s) of the actual data row(s) in the table leaf pages.', example: 'Think of the index at the back of a book. This page might contain entries like:\nKey: "Smith", points to -> RowIDs [101, 234, 567]\nKey: "Jones", points to -> RowIDs [89, 444]\nThe cell details would show something like:\n<code>Payload Size: 5, Key Data @ 4050 (containing "Smith")</code>' },
            'table-internal': { title: 'Table Internal Page', explanation: 'Acts like a signpost within the main table\'s B-tree structure. It doesn\'t hold row data itself, but contains RowIDs (keys) that guide the search towards the correct leaf page based on the RowID being sought.', example: 'Imagine navigating a large library by aisle numbers. This page might say:\n"RowIDs < 500: Go Left (to Page 10)"\n"RowIDs >= 500: Go Right (to Page 12)"\nThe cell details would show:\n<code>Left Child -> pg 10, Key (RowID): 500</code>' },
            'index-internal': { title: 'Index Internal Page', explanation: 'Acts like a signpost within an index\'s B-tree structure. It contains indexed values (keys) that guide the search towards the correct index leaf page based on the value being sought.', example: 'Navigating the book index by letter. This page might say:\n"Keys < \'M\': Go Left (to Page 25)"\n"Keys >= \'M\': Go Right (to Page 28)"\nThe cell details would show:\n<code>Left Child -> pg 25, Payload Size: 1, Key Data @ 3000 (containing "M")</code>' },
            'overflow': { title: 'Overflow Page', explanation: 'Used when a single piece of data (like a large text block, a BLOB image, or a very wide index entry) is too big to fit entirely on its primary leaf page. This page holds a chunk of that oversized data and usually points to the *next* overflow page if more data follows.', example: 'Imagine a footnote that\'s too long for the bottom of the page. This page contains the middle part of that footnote. Its first few bytes might point to Page 60, where the rest of the footnote continues.' },
            'freelist-trunk': { title: 'Freelist Trunk Page', explanation: 'Part of SQLite\'s system for managing unused disk space. A trunk page doesn\'t list free pages directly, but contains pointers to multiple "Freelist Leaf" pages. It helps organize the freelist when there are many free pages.', example: 'Think of it as a directory for empty office rooms. This page lists the locations (page numbers) of several lists of empty rooms, like:\n"See Leaf Page 15 for some free pages"\n"See Leaf Page 30 for more free pages"\nIt also points to the next trunk page if the directory itself is large.' },
            'freelist-leaf': { title: 'Freelist Leaf Page', explanation: 'This page contains a list of page numbers that are currently unused within the database file. SQLite can reuse these pages when new data needs to be written, avoiding the need to grow the file immediately.', example: 'A list of empty office room numbers: [7, 18, 25, 41, 55, ...]. SQLite can pick one of these page numbers when it needs space.' },
            'unknown': { title: 'Unknown / Other Page', explanation: 'A page whose type flag was not recognized as one of the standard B-tree, Overflow, or Freelist types by this visualizer. This could potentially be:\n- Page 1 (which also contains the main file header).\n- The "lock-byte page" (used for concurrency control).\n- Part of a pointer map (used in WAL mode, less common in the main DB file).\n- A corrupted page.\n- A newer page type not yet handled by this tool.', example: 'Often Page 1 is the only one marked Unknown initially, as it starts with the 100-byte file header before its page data.' }
        };

        // --- Event Listeners ---
        fileInput.addEventListener('change', handleFileSelect, false);
        pageDetailCloseBtn.addEventListener('click', hidePageDetailDialog); // Use specific handler
        legendHelpCloseBtn.addEventListener('click', hideLegendHelp);
        // Use separate overlays logically
        pageDetailOverlay.addEventListener('click', hidePageDetailDialog);
        legendHelpOverlay.addEventListener('click', hideLegendHelp);

        pageMapLegend.addEventListener('click', function(event) {
            if (event.target && event.target.classList.contains('legend-term')) {
                const term = event.target.dataset.term;
                if (term) {
                    showLegendHelp(term);
                }
            }
        });
        // Delegate "Show More" clicks from the body
        document.body.addEventListener('click', function(event) {
            if (event.target && event.target.classList.contains('show-more-btn')) {
                handleShowMoreClick(event);
            }
        });


        // --- Helper: Read Varint (Formatted) ---
        function readVarint(dataView, offset) {
            let value = 0;
            let bytesRead = 0;
            let maxOffset = dataView.byteLength - 1;

            for (let i = 0; i < 9; i++) {
                if (offset + i > maxOffset) {
                    console.warn(`readVarint: Read past buffer end @ ${offset + i}`);
                    return { value: 0, bytesRead: i, error: "Read past buffer end" };
                }
                let byte = dataView.getUint8(offset + i);
                bytesRead++;
                if (i < 8) {
                    value = (value << 7) | (byte & 0x7f);
                    if ((byte & 0x80) === 0) { // Last byte has MSB unset
                        return { value: value, bytesRead: bytesRead };
                    }
                } else { // 9th byte uses all bits
                    value = (value << 8) | byte;
                    return { value: value, bytesRead: bytesRead };
                }
            }
            console.error(`readVarint: Invalid varint structure @ ${offset}`);
            return { value: 0, bytesRead: bytesRead, error: "Invalid varint structure" };
        }

        // --- Helper: Format Hex/ASCII Dump (Formatted) ---
        function formatHexAsciiDump(dataView, offset, length, indent = 4) {
            const requestedLength = Math.max(0, length);
            if (requestedLength === 0) {
                return "";
            }
            const indentStr = ' '.repeat(indent);
            let lines = [];
            const maxOffset = dataView.byteLength;

            if (offset >= maxOffset || offset < 0) {
                return `<div class="data-dump">[Invalid start offset ${offset}]</div>`;
            }
            const actualLength = Math.min(requestedLength, maxOffset - offset);
            if (actualLength <= 0) {
                return `<div class="data-dump">[No data available at offset ${offset}]</div>`;
            }

            lines.push(`Data @ Offset ${offset} (showing ${actualLength}/${requestedLength} requested bytes):`);

            let hexString = "";
            let asciiString = "";
            for (let i = 0; i < actualLength; i++) {
                if (offset + i >= maxOffset) {
                    break;
                }
                const byte = dataView.getUint8(offset + i);
                hexString += byte.toString(16).padStart(2, '0') + " ";
                asciiString += (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : ".";

                if ((i + 1) % 16 === 0) {
                    lines.push(indentStr + hexString.trim().padEnd(47) + " | " + asciiString);
                    hexString = "";
                    asciiString = "";
                }
            }
            if (hexString) {
                lines.push(indentStr + hexString.trim().padEnd(47) + " | " + asciiString);
            }
            return `<div class="data-dump">${lines.join('\n')}</div>`;
        }


        // --- Helper: Parse Cell Summary (Formatted) ---
        function parseCellSummary(dataView, pageOffset, cellOffsetInPage, pageType, pageSize, pageNum, cellIndex) {
            const cellStart = pageOffset + cellOffsetInPage;
            let summary = `Cell [${cellIndex}] @ Offset ${cellOffsetInPage}: `;
            let dataDumpHtml = "";
            let bytesAvailable = (pageOffset + pageSize) - cellStart;
            const dumpContainerId = `dump-${pageNum}-${cellIndex}`;

            try {
                const pageHeaderSizeForCalc = pageData.find(p => p.pageNum === pageNum)?.pageHeaderSize || 0;
                const cellCountForCalc = pageData.find(p => p.pageNum === pageNum)?.header?.cellCount || 0;
                const headerEndOffsetAbsolute = pageOffset + (pageNum === 1 ? 100 : 0) + pageHeaderSizeForCalc + (cellCountForCalc * 2);

                 if (cellOffsetInPage <= 0 || cellStart < headerEndOffsetAbsolute || bytesAvailable <= 0) {
                      let errorMsg = "";
                      if (cellStart < headerEndOffsetAbsolute && cellOffsetInPage > 0) {
                          errorMsg = `[Invalid Offset ${cellOffsetInPage} - points inside header/pointer area ending at ${headerEndOffsetAbsolute - pageOffset}]`;
                      } else if (bytesAvailable <= 0) {
                          errorMsg = "[No space available at offset]";
                      } else {
                          errorMsg = `[Suspicious Offset ${cellOffsetInPage}]`;
                      }
                      console.warn(`Page ${pageNum}, Cell ${cellIndex}: ${errorMsg}`);
                      return { summaryText: summary + errorMsg, dumpHtml:"" };
                 }

                const usablePageSize = pageSize - (fileHeaderInfo?.reservedSpace || 0);
                let payloadStartOffset = 0;
                let maxBytesOnPageForPayload = 0;
                let initialBytesToDump = 0;
                let actualPayloadSize = -1;

                switch (pageType) {
                    case 'table-leaf': {
                        if (bytesAvailable < 1) return { summaryText: summary + "[Too small]", dumpHtml:"" };
                        const plSizeInfo = readVarint(dataView, cellStart);
                        if (plSizeInfo.error) return { summaryText: summary + `[Err PayloadSz: ${plSizeInfo.error}]`, dumpHtml:"" };
                        actualPayloadSize = plSizeInfo.value;
                        let currentOffset = cellStart + plSizeInfo.bytesRead;
                        summary += `Payload Size: ${actualPayloadSize}, `;
                        if ((currentOffset - pageOffset) + 1 > pageSize) return { summaryText: summary + "[Offset exceeds page]", dumpHtml:"" };
                        const rowIdInfo = readVarint(dataView, currentOffset);
                        if (rowIdInfo.error) return { summaryText: summary + `[Err RowID @${currentOffset-pageOffset}: ${rowIdInfo.error}]`, dumpHtml:"" };
                        summary += `RowID: ${rowIdInfo.value}`;
                        currentOffset += rowIdInfo.bytesRead;
                        payloadStartOffset = currentOffset;
                        maxBytesOnPageForPayload = (pageOffset + pageSize) - payloadStartOffset;
                        const maxPayloadOnPage = usablePageSize - 35;
                        const minPayloadForOverflow = maxPayloadOnPage + 1;
                        if (actualPayloadSize >= minPayloadForOverflow && maxBytesOnPageForPayload >= 4) {
                            const overflowPageNum = dataView.getUint32(payloadStartOffset, false);
                            if (overflowPageNum > 0) {
                                summary += `, Overflow -> pg ${overflowPageNum}`;
                                const currentPageData = pageData.find(p => p.pageNum === pageNum);
                                if (currentPageData && !currentPageData.links.some(l => l.targetPage === overflowPageNum && l.type === 'overflow')) {
                                    currentPageData.links.push({ targetPage: overflowPageNum, type: 'overflow', cellOffset: cellOffsetInPage });
                                }
                            } else { summary += `, [Overflow Expected, Ptr=0?]`; }
                            initialBytesToDump = Math.min(maxBytesOnPageForPayload, DUMP_LENGTH);
                        } else if (actualPayloadSize > 0 && maxBytesOnPageForPayload > 0) {
                            const headerSizeInfo = readVarint(dataView, payloadStartOffset);
                            if (!headerSizeInfo.error) { summary += `, Record Header Size: ${headerSizeInfo.value}`; }
                            initialBytesToDump = Math.min(maxBytesOnPageForPayload, actualPayloadSize, DUMP_LENGTH);
                        } else { maxBytesOnPageForPayload = 0; }
                        break;
                    }
                    case 'index-leaf': {
                        if (bytesAvailable < 1) return { summaryText: summary + "[Too small]", dumpHtml:"" };
                        const idxLeafPlSizeInfo = readVarint(dataView, cellStart);
                        if (idxLeafPlSizeInfo.error) return { summaryText: summary + `[Err PayloadSz: ${idxLeafPlSizeInfo.error}]`, dumpHtml:"" };
                        actualPayloadSize = idxLeafPlSizeInfo.value;
                        summary += `Payload Size: ${actualPayloadSize}`;
                        let currentOffset = cellStart + idxLeafPlSizeInfo.bytesRead;
                        payloadStartOffset = currentOffset;
                        maxBytesOnPageForPayload = (pageOffset + pageSize) - payloadStartOffset;
                        summary += `, Key Data @ ${payloadStartOffset - pageOffset}`;
                        const idxMaxPayload = usablePageSize - 20;
                        if (actualPayloadSize >= (idxMaxPayload + 1) && maxBytesOnPageForPayload >= 4) {
                            const overflowPageNum = dataView.getUint32(payloadStartOffset, false);
                            if (overflowPageNum > 0) {
                                summary += `, Overflow -> pg ${overflowPageNum}`;
                                const currentPageData = pageData.find(p => p.pageNum === pageNum);
                                if (currentPageData && !currentPageData.links.some(l => l.targetPage === overflowPageNum && l.type === 'overflow')) {
                                    currentPageData.links.push({ targetPage: overflowPageNum, type: 'overflow', cellOffset: cellOffsetInPage });
                                }
                            } else { summary += `, [Overflow Expected, Ptr=0?]`; }
                            initialBytesToDump = Math.min(maxBytesOnPageForPayload, DUMP_LENGTH);
                        } else { initialBytesToDump = Math.min(maxBytesOnPageForPayload, actualPayloadSize, DUMP_LENGTH); }
                        break;
                    }
                    case 'table-internal': {
                        if (bytesAvailable < 4) return { summaryText: summary + "[Too small]", dumpHtml:"" };
                        const leftChildPtr = dataView.getUint32(cellStart, false);
                        summary += `Left Child -> pg ${leftChildPtr}, `;
                        let currentOffset = cellStart + 4;
                        if ((currentOffset - pageOffset) + 1 > pageSize) return { summaryText: summary + "[Offset exceeds page]", dumpHtml:"" };
                        const keyRowIdInfo = readVarint(dataView, currentOffset);
                        if (keyRowIdInfo.error) return { summaryText: summary + `[Err Key @${currentOffset-pageOffset}: ${keyRowIdInfo.error}]`, dumpHtml:"" };
                        summary += `Key (RowID): ${keyRowIdInfo.value}`;
                        payloadStartOffset = currentOffset;
                        maxBytesOnPageForPayload = keyRowIdInfo.bytesRead;
                        initialBytesToDump = maxBytesOnPageForPayload;
                        break;
                    }
                    case 'index-internal': {
                        if (bytesAvailable < 4) return { summaryText: summary + "[Too small]", dumpHtml:"" };
                        const idxIntChildPtr = dataView.getUint32(cellStart, false);
                        summary += `Left Child -> pg ${idxIntChildPtr}, `;
                        let currentOffset = cellStart + 4;
                        if ((currentOffset - pageOffset) + 1 > pageSize) return { summaryText: summary + "[Offset exceeds page]", dumpHtml:"" };
                        const idxIntPlSizeInfo = readVarint(dataView, currentOffset);
                        if (idxIntPlSizeInfo.error) return { summaryText: summary + `[Err PayloadSz @${currentOffset-pageOffset}: ${idxIntPlSizeInfo.error}]`, dumpHtml:"" };
                        actualPayloadSize = idxIntPlSizeInfo.value;
                        summary += `Payload Size: ${actualPayloadSize}`;
                        currentOffset += idxIntPlSizeInfo.bytesRead;
                        payloadStartOffset = currentOffset;
                        maxBytesOnPageForPayload = (pageOffset + pageSize) - payloadStartOffset;
                        summary += `, Key Data @ ${payloadStartOffset - pageOffset}`;
                        const idxIntMaxPayload = usablePageSize - 25;
                        if (actualPayloadSize >= (idxIntMaxPayload + 1) && maxBytesOnPageForPayload >= 4) {
                            const overflowPageNum = dataView.getUint32(payloadStartOffset, false);
                            if (overflowPageNum > 0) {
                                summary += `, Overflow -> pg ${overflowPageNum}`;
                                const currentPageData = pageData.find(p => p.pageNum === pageNum);
                                if (currentPageData && !currentPageData.links.some(l => l.targetPage === overflowPageNum && l.type === 'overflow')) {
                                    currentPageData.links.push({ targetPage: overflowPageNum, type: 'overflow', cellOffset: cellOffsetInPage });
                                }
                            } else { summary += `, [Overflow Expected, Ptr=0?]`; }
                            initialBytesToDump = Math.min(maxBytesOnPageForPayload, DUMP_LENGTH);
                        } else { initialBytesToDump = Math.min(maxBytesOnPageForPayload, actualPayloadSize, DUMP_LENGTH); }
                        break;
                    }
                    default: {
                        summary += `[Raw Data - Type ${pageType} cell format not decoded]`;
                        payloadStartOffset = cellStart;
                        maxBytesOnPageForPayload = bytesAvailable;
                        initialBytesToDump = Math.min(bytesAvailable, DUMP_LENGTH);
                        break;
                    }
                } // End switch

                initialBytesToDump = Math.max(0, initialBytesToDump);
                maxBytesOnPageForPayload = Math.max(0, maxBytesOnPageForPayload);

                if (maxBytesOnPageForPayload > 0) {
                    const initialDump = formatHexAsciiDump(dataView, payloadStartOffset, initialBytesToDump);
                    dataDumpHtml += `<div id="${dumpContainerId}" class="dump-content-container">${initialDump}</div>`;
                    if (maxBytesOnPageForPayload > initialBytesToDump) {
                        dataDumpHtml += `<button class="show-more-btn" data-target-id="${dumpContainerId}" data-start-offset="${payloadStartOffset}" data-max-bytes="${maxBytesOnPageForPayload}">Show All (${maxBytesOnPageForPayload} bytes on page)</button>`;
                    }
                } else {
                    dataDumpHtml = `<div class="data-dump">[No data to dump for this cell]</div>`;
                }

            } catch (e) {
                console.error(`Error parsing cell ${cellIndex} @ ${cellOffsetInPage} on page ${pageNum} (Type ${pageType}):`, e);
                summary += ` [Exception: ${e.message}]`;
            }
            return { summaryText: summary, dumpHtml: dataDumpHtml };
        } // End parseCellSummary


        // --- Handle "Show More" Clicks ---
        function handleShowMoreClick(event) {
            const button = event.target;
            const targetId = button.dataset.targetId;
            const startOffset = parseInt(button.dataset.startOffset, 10);
            const maxBytes = parseInt(button.dataset.maxBytes, 10);

            if (isNaN(startOffset) || isNaN(maxBytes) || !targetId) {
                 console.error("Invalid data attributes on 'Show More' button:", button.dataset);
                 return;
            }
            const dumpContainer = document.getElementById(targetId);
            if (!dumpContainer) {
                console.error("Could not find dump container with ID:", targetId);
                return;
            }
            if (!fileBuffer) {
                 console.error("File buffer is not available.");
                 dumpContainer.innerHTML = `<div class="data-dump">[Error: File data unavailable]</div>`;
                 return;
            }

            try {
                console.log(`Expanding dump for ${targetId}: Offset=${startOffset}, MaxBytes=${maxBytes}`);
                const dataView = new DataView(fileBuffer);
                const fullDumpHtml = formatHexAsciiDump(dataView, startOffset, maxBytes);
                dumpContainer.innerHTML = fullDumpHtml; // Replace content
                button.style.display = 'none'; // Hide button
            } catch (error) {
                 console.error(`Error generating full dump for ${targetId}:`, error);
                 dumpContainer.innerHTML = `<div class="data-dump">[Error generating full dump: ${error.message}]</div>`;
                 button.style.display = 'none';
            }
        }

        // --- Dialog Show/Hide ---
        function showPageDetailDialog() {
            document.body.classList.add('dialog-visible');
            document.body.classList.remove('legend-dialog-visible'); // Ensure legend is hidden
        }
        function hidePageDetailDialog() {
            document.body.classList.remove('dialog-visible');
            pageDetailContent.innerHTML = '<p>Loading...</p>'; // Reset content
            pageDetailTitle.textContent = 'Page Details';
        }
        function showLegendHelp(term) {
            const helpData = legendExplanations[term];
            if (helpData) {
                legendHelpTitle.textContent = helpData.title || 'Legend Help';
                // Escape HTML in example before injecting
                const safeExample = helpData.example ? helpData.example.replace(/</g, "<").replace(/>/g, ">") : '';
                legendHelpContent.innerHTML = `
                    <p>${helpData.explanation}</p>
                    ${helpData.example ? `<h3>Example:</h3><pre>${safeExample}</pre>` : ''}
                `;
                document.body.classList.add('legend-dialog-visible');
                document.body.classList.remove('dialog-visible'); // Ensure page detail is hidden
            } else {
                console.warn("No explanation found for term:", term);
            }
        }
        function hideLegendHelp() {
            document.body.classList.remove('legend-dialog-visible');
            legendHelpContent.innerHTML = ''; // Clear content
            legendHelpTitle.textContent = 'Legend Explanation';
        }

        // --- File Handling and Parsing Logic ---
        function handleFileSelect(event) {
             const file = event.target.files[0];
             if (!file) {
                 return;
             }
             resetUIAndData();
             headerOutput.textContent = 'Reading file...';

             const reader = new FileReader();
             reader.onload = function(e) {
                 fileBuffer = e.target.result;
                 console.log(`FileReader onload: Read ${fileBuffer.byteLength} bytes.`);
                 if (!fileBuffer || fileBuffer.byteLength < 100) {
                     console.error("File buffer seems empty or too small after read.");
                     headerOutput.textContent = "Error: Failed to read file content or file is too small.";
                     return;
                 }
                 try {
                     console.log("Starting parseSqliteFile...");
                     parseSqliteFile(fileBuffer);
                     console.log("Finished parseSqliteFile. Starting rendering...");

                     renderHeaderInfo();
                     console.log("Finished renderHeaderInfo.");

                     renderPageMap();
                     console.log("Finished renderPageMap.");

                     renderLinks();
                     console.log("Finished renderLinks.");

                     hidePageDetailDialog(); // Ensure dialogs are hidden initially
                     hideLegendHelp();
                     console.log("UI updated for successful load.");

                 } catch (error) {
                     console.error("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
                     console.error("!!! Critical Error caught in onload:", error);
                     console.error("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
                     headerOutput.textContent = `Error processing file: ${error.message}\nSee console for details.`;
                     hidePageDetailDialog(); // Ensure dialogs hidden on error
                     hideLegendHelp();
                 }
             };
             reader.onerror = function(e) {
                 console.error("FileReader error:", e);
                 headerOutput.textContent = "Error reading file.";
                 resetUIAndData();
             };
             reader.readAsArrayBuffer(file);
        }

        function resetUIAndData() {
             headerOutput.textContent = 'Upload a SQLite file to begin...';
             pageMapDiv.innerHTML = '';
             linkOverlay.innerHTML = '';
             hidePageDetailDialog();
             hideLegendHelp();
             pageData = [];
             fileHeaderInfo = {};
             pageSize = 0;
             fileBuffer = null;
             // console.clear(); // Optional: Clear console
        }

        function parseSqliteFile(buffer) {
            pageData = [];
            fileHeaderInfo = {};
            const dataView = new DataView(buffer);

            // --- 1. Parse File Header (Bytes 0-99) ---
            console.group("Parsing File Header");
            console.log("Attempting to read first 16 bytes for magic string...");
            const expectedMagic = "SQLite format 3\0";
            let actualMagic = "";
            let actualBytesHex = [];
            try {
                if (buffer.byteLength < 16) {
                    throw new Error(`File buffer too small (${buffer.byteLength} bytes)`);
                }
                for (let i = 0; i < 16; i++) {
                    const byte = dataView.getUint8(i);
                    actualBytesHex.push(byte.toString(16).padStart(2, '0'));
                    actualMagic += String.fromCharCode(byte);
                }
                console.log("First 16 bytes (hex):", actualBytesHex.join(' '));
                console.log("String constructed:", JSON.stringify(actualMagic));
                console.log("Expected string   :", JSON.stringify(expectedMagic));
                console.log("Match?", actualMagic === expectedMagic);
            } catch (e) {
                console.error("Error reading first 16 bytes:", e);
                console.groupEnd();
                throw new Error(`Failed to read file header bytes. Original error: ${e.message}`);
            }

            if (actualMagic !== expectedMagic) {
                 console.error(`Magic string mismatch.`);
                 console.groupEnd();
                 throw new Error(`Not a valid SQLite 3 file. Header check failed.`);
            } else {
                console.log("Magic string check PASSED.");
            }

            pageSize = dataView.getUint16(16, false); // Big-Endian
            if (pageSize === 1) {
                pageSize = 65536;
            }
            if (pageSize === 0 || pageSize < 512 || pageSize > 65536 || (pageSize & (pageSize - 1)) !== 0) {
                 console.error(`Invalid page size: ${pageSize}`);
                 console.groupEnd();
                 throw new Error(`Invalid page size ${pageSize} found in header.`);
            }
            console.log(`Page Size: ${pageSize}`);

            fileHeaderInfo = {
                magic: actualMagic, pageSize: pageSize,
                writeVersion: dataView.getUint8(18), readVersion: dataView.getUint8(19),
                reservedSpace: dataView.getUint8(20), maxPayloadFrac: dataView.getUint8(21),
                minPayloadFrac: dataView.getUint8(22), leafPayloadFrac: dataView.getUint8(23),
                fileChangeCounter: dataView.getUint32(24, false), headerDbSizeInPages: dataView.getUint32(28, false),
                firstFreelistPage: dataView.getUint32(32, false), totalFreelistPages: dataView.getUint32(36, false),
                schemaCookie: dataView.getUint32(40, false), schemaFormat: dataView.getUint32(44, false),
                defaultPageCacheSize: dataView.getUint32(48, false), largestRootPage: dataView.getUint32(52, false),
                textEncoding: dataView.getUint32(56, false), userVersion: dataView.getUint32(60, false),
                incrementalVacuumMode: dataView.getUint32(64, false), appId: dataView.getUint32(68, false),
                versionValidFor: dataView.getUint32(92, false), sqliteVersionNum: dataView.getUint32(96, false)
            };

            const numPages = Math.floor(buffer.byteLength / pageSize);
            fileHeaderInfo.calculatedDbSizeInPages = numPages;
            if (fileHeaderInfo.headerDbSizeInPages > 0 && fileHeaderInfo.headerDbSizeInPages !== numPages) {
                console.warn(`Header DB size (${fileHeaderInfo.headerDbSizeInPages}) differs from calculated size (${numPages}). Using calculated size.`);
            } else if (fileHeaderInfo.headerDbSizeInPages === 0) {
                 console.log(`Header DB size is 0, using calculated size: ${numPages}`);
            }
            console.log(`Calculated Page Count: ${numPages}`);
            console.groupEnd(); // End Header Parsing group

            pageData.push({ pageNum: 0, type: 'file-header', headerInfo: fileHeaderInfo });

             // --- 2. Iterate Through Actual Pages ---
             console.groupCollapsed("Parsing Individual Pages");
             for (let i = 1; i <= numPages; i++) {
                const pageOffset = (i - 1) * pageSize;
                let pageHeaderOffset = (i === 1) ? 100 : 0;
                const headerBase = pageOffset + pageHeaderOffset;

                if (headerBase >= buffer.byteLength) {
                     console.error(`Page ${i}: Offset ${headerBase} exceeds buffer length ${buffer.byteLength}. Stopping.`);
                     break;
                }

                const pageTypeFlag = dataView.getUint8(headerBase);
                let pageType = 'unknown';
                let pageHeaderSize = 8; // Default for leaves

                switch (pageTypeFlag) {
                    case 0x02: pageType = 'index-internal'; pageHeaderSize = 12; break;
                    case 0x05: pageType = 'table-internal'; pageHeaderSize = 12; break;
                    case 0x0a: pageType = 'index-leaf'; pageHeaderSize = 8; break;
                    case 0x0d: pageType = 'table-leaf'; pageHeaderSize = 8; break;
                }

                let pageInfo = {
                    pageNum: i, type: pageType, links: [], header: {},
                    rawOffset: pageOffset, pageHeaderSize: pageHeaderSize, cellOffsets: []
                };

                if (pageType !== 'unknown') {
                    if (headerBase + pageHeaderSize > buffer.byteLength) {
                         console.warn(`Page ${i}: Not enough space for ${pageType} header.`);
                         pageInfo.header.error = "Header truncated";
                    } else {
                         pageInfo.header = {
                             flag: pageTypeFlag,
                             firstFreeblockOffset: dataView.getUint16(headerBase + 1, false),
                             cellCount: dataView.getUint16(headerBase + 3, false),
                             cellContentStartOffset: dataView.getUint16(headerBase + 5, false),
                             fragmentedFreeBytes: dataView.getUint8(headerBase + 7)
                         };
                         if (pageHeaderSize === 12) {
                             pageInfo.header.rightMostPointer = dataView.getUint32(headerBase + 8, false);
                             const rightPtr = pageInfo.header.rightMostPointer;
                             if (rightPtr > 0 && rightPtr <= numPages) {
                                 pageInfo.links.push({ targetPage: rightPtr, type: 'btree-child', detail: 'right-most' });
                             } else if (rightPtr !== 0) {
                                 console.warn(`Page ${i}: Invalid right-most pointer ${rightPtr}`);
                             }
                         }
                         if (pageInfo.header.cellContentStartOffset === 0 && pageInfo.header.cellCount > 0) {
                             pageInfo.header.cellContentStartOffset = pageSize;
                             console.log(`Page ${i}: Corrected cellContentStartOffset 0 to ${pageSize}`);
                         }
                    }
                } else {
                     pageInfo.pageHeaderSize = 0;
                     pageInfo.header = { flag: pageTypeFlag, note: "Not a known B-tree page type" };
                }

                if (pageInfo.header.cellCount > 0 && pageType !== 'unknown') {
                    const cellPointerArrayStart = headerBase + pageHeaderSize;
                    const cellPointerArrayEnd = cellPointerArrayStart + pageInfo.header.cellCount * 2;

                    if (cellPointerArrayEnd > pageOffset + pageSize) {
                         console.warn(`Page ${i}: Cell pointer array extends beyond page boundary.`);
                         pageInfo.header.error = (pageInfo.header.error || "") + " Cell pointer array truncated.";
                    } else {
                         for (let c = 0; c < pageInfo.header.cellCount; c++) {
                             const pointerOffset = cellPointerArrayStart + (c * 2);
                             const cellOffsetInPage = dataView.getUint16(pointerOffset, false);
                             const headerAndPointersEndAbsolute = cellPointerArrayEnd;
                             if (cellOffsetInPage > 0 &&
                                 cellOffsetInPage < pageSize &&
                                 (pageOffset + cellOffsetInPage) >= headerAndPointersEndAbsolute)
                             {
                                pageInfo.cellOffsets.push(cellOffsetInPage);
                             } else {
                                console.warn(`Page ${i}: Cell ${c} invalid offset ${cellOffsetInPage} (Hdr/Ptrs end at ${headerAndPointersEndAbsolute - pageOffset}, PgSz ${pageSize}). Storing 0.`);
                                pageInfo.cellOffsets.push(0);
                             }
                         }
                         pageInfo.cellOffsets.sort((a, b) => {
                             if (a === 0 && b === 0) return 0;
                             if (a === 0) return 1;
                             if (b === 0) return -1;
                             return a - b;
                         });
                     }
                 }

                 if (pageInfo.type === 'table-internal' || pageInfo.type === 'index-internal') {
                     pageInfo.cellOffsets.forEach((cellOffset, cIdx) => {
                         if (cellOffset > 0 && (pageOffset + cellOffset + 4) <= (pageOffset + pageSize)) {
                             const actualCellOffset = pageOffset + cellOffset;
                             const leftChildPage = dataView.getUint32(actualCellOffset, false);
                             if (leftChildPage > 0 && leftChildPage <= numPages) {
                                  if (!pageInfo.links.some(l => l.targetPage === leftChildPage && l.type === 'btree-child')) {
                                     pageInfo.links.push({ targetPage: leftChildPage, type: 'btree-child', detail: `cell ${cIdx}` });
                                  }
                             } else if (leftChildPage !== 0) {
                                  console.warn(`Page ${i}, Cell ${cIdx} (Offset ${cellOffset}): Invalid left child pointer ${leftChildPage}`);
                             }
                         }
                     });
                 }
                pageData.push(pageInfo);
             } // End page loop
             console.groupEnd(); // End Page Parsing group


            // --- 3. Refine Page Types & Links (Freelist Traversal) ---
            console.groupCollapsed("Processing Freelist");
            let freelistPageCount = 0;
            let currentFreelistTrunk = fileHeaderInfo.firstFreelistPage;
            let visitedFreelist = new Set();

            while (currentFreelistTrunk > 0 && currentFreelistTrunk <= numPages && !visitedFreelist.has(currentFreelistTrunk)) {
                 visitedFreelist.add(currentFreelistTrunk);
                 const flTrunkPage = pageData.find(p => p.pageNum === currentFreelistTrunk);
                 if (flTrunkPage) {
                     if (flTrunkPage.type !== 'unknown') {
                         console.warn(`Page ${currentFreelistTrunk} is freelist trunk, but typed as ${flTrunkPage.type}. Overwriting.`);
                     }
                     flTrunkPage.type = 'freelist-trunk';
                     flTrunkPage.pageHeaderSize = 0;

                     const pageOffset = flTrunkPage.rawOffset;
                     if (pageOffset + 8 > buffer.byteLength) {
                         console.error(`Freelist Trunk ${currentFreelistTrunk}: Page truncated.`);
                         flTrunkPage.header = { error: "Truncated page" };
                         break;
                     }
                     const nextTrunkPageNum = dataView.getUint32(pageOffset, false);
                     const numLeaves = dataView.getUint32(pageOffset + 4, false);
                     flTrunkPage.header = { nextTrunk: nextTrunkPageNum, numLeafPointers: numLeaves };

                     if (nextTrunkPageNum > 0 && nextTrunkPageNum <= numPages) {
                        flTrunkPage.links.push({targetPage: nextTrunkPageNum, type: 'freelist-next-trunk'});
                     } else if (nextTrunkPageNum !== 0) {
                         console.warn(`Freelist Trunk ${currentFreelistTrunk}: Invalid next trunk pointer ${nextTrunkPageNum}`);
                     }
                     freelistPageCount++;

                     const leafPointerStartOffset = pageOffset + 8;
                     const maxLeavesReadable = Math.floor((pageSize - 8) / 4);
                     const actualNumLeaves = Math.min(numLeaves, maxLeavesReadable);
                     if (numLeaves > maxLeavesReadable) {
                         console.warn(`Freelist Trunk ${currentFreelistTrunk}: Header claims ${numLeaves} leaves, only ${maxLeavesReadable} fit.`);
                     }

                     for (let k = 0; k < actualNumLeaves; k++) {
                         const leafPointerOffset = leafPointerStartOffset + (k * 4);
                         if (leafPointerOffset + 4 > pageOffset + pageSize) {
                              console.warn(`Freelist Trunk ${currentFreelistTrunk}: Attempted read beyond page boundary for leaf pointer ${k}.`);
                              break;
                         }
                         const leafPageNum = dataView.getUint32(leafPointerOffset, false);

                         if (leafPageNum > 0 && leafPageNum <= numPages) {
                              flTrunkPage.links.push({targetPage: leafPageNum, type: 'freelist-leaf-ptr'});
                              const flLeafPage = pageData.find(p => p.pageNum === leafPageNum);
                              if (flLeafPage) {
                                   if (flLeafPage.type !== 'unknown') {
                                        console.warn(`Page ${leafPageNum} is freelist leaf, but typed as ${flLeafPage.type}. Overwriting.`);
                                   }
                                   flLeafPage.type = 'freelist-leaf';
                                   flLeafPage.pageHeaderSize = 0;
                                   freelistPageCount++;
                                   flLeafPage.header = { note: "Contains list of free page numbers" };
                              } else {
                                  console.warn(`Freelist Trunk ${currentFreelistTrunk}: Points to non-existent leaf page ${leafPageNum}`);
                              }
                         } else if (leafPageNum !== 0) {
                              console.warn(`Freelist Trunk ${currentFreelistTrunk}: Invalid leaf pointer ${leafPageNum} at index ${k}`);
                         }
                     } // End leaf pointer loop
                     currentFreelistTrunk = nextTrunkPageNum;
                 } else {
                     console.warn(`Freelist traversal stopped: Could not find page data for page ${currentFreelistTrunk}`);
                     break;
                 }
            } // End while freelist trunk loop

            if (visitedFreelist.has(currentFreelistTrunk) && currentFreelistTrunk !== 0) {
                console.warn("Freelist traversal encountered a cycle.");
            }
             console.log(`Identified ${freelistPageCount} freelist pages via traversal.`);
             if (fileHeaderInfo.totalFreelistPages !== freelistPageCount) {
                console.warn(`Header reported ${fileHeaderInfo.totalFreelistPages} freelist pages, but traversal found ${freelistPageCount}.`);
             }
             fileHeaderInfo.traversedFreelistPageCount = freelistPageCount;
             console.groupEnd(); // End Freelist group


            // --- 4. Identify Overflow Pages ---
            console.groupCollapsed("Processing Overflow Pages");
            let overflowPagesFound = new Set();
            pageData.forEach(page => {
                if (!page || page.pageNum === 0 || !Array.isArray(page.links)) {
                    return; // Skip invalid entries
                }
                // Find links added by parseCellSummary
                page.links.filter(link => link.type === 'overflow').forEach(link => {
                    const targetPageNum = link.targetPage;
                    if (targetPageNum > 0 && targetPageNum <= numPages) {
                         const overflowPage = pageData.find(p => p.pageNum === targetPageNum);
                         if (overflowPage) {
                             if (overflowPage.type !== 'unknown' && overflowPage.type !== 'overflow') {
                                console.warn(`Page ${targetPageNum} is overflow, but typed as ${overflowPage.type}. Overwriting.`);
                             } else if (overflowPage.type === 'unknown') {
                                console.log(`Marking page ${targetPageNum} as overflow (linked from page ${page.pageNum})`);
                             }
                              overflowPage.type = 'overflow';
                              overflowPage.pageHeaderSize = 0; // No B-tree header

                              // Parse next overflow page link from start of overflow page
                              const ovfPageOffset = overflowPage.rawOffset;
                              if (ovfPageOffset + 4 <= buffer.byteLength) {
                                  const nextOverflowPage = dataView.getUint32(ovfPageOffset, false);
                                  overflowPage.header = { ...(overflowPage.header || {}), nextOverflowPage: nextOverflowPage };
                                  if (nextOverflowPage > 0 && nextOverflowPage <= numPages) {
                                       // Add link if not already present
                                       if (!overflowPage.links.some(l => l.targetPage === nextOverflowPage && l.type === 'overflow-next')) {
                                            overflowPage.links.push({ targetPage: nextOverflowPage, type: 'overflow-next' });
                                       }
                                  } else if (nextOverflowPage !== 0) {
                                       console.warn(`Overflow Page ${targetPageNum}: Invalid next overflow pointer ${nextOverflowPage}`);
                                  }
                              } else {
                                  overflowPage.header = { ...(overflowPage.header || {}), error: "Truncated page" };
                              }
                              overflowPagesFound.add(targetPageNum);
                         } else {
                             console.warn(`Page ${page.pageNum} links to non-existent overflow page ${targetPageNum}`);
                         }
                    } // end if valid target page
                }); // End forEach overflow link
            }); // End forEach page
            console.log(`Identified ${overflowPagesFound.size} unique pages as overflow based on links.`);
            console.groupEnd(); // End Overflow group

            console.log("Finished Parsing. Final Page Data Structure Ready.");
        } // End parseSqliteFile


        // --- UI Rendering Functions ---
        function renderHeaderInfo() {
             if (fileHeaderInfo && fileHeaderInfo.pageSize) {
                let text = ``; // Start fresh
                let fileSizeKB = fileInput.files[0] ? (fileInput.files[0].size / 1024).toFixed(1) : 'N/A';
                let fileName = fileInput.files[0] ? fileInput.files[0].name : 'N/A';
                text += `File: ${fileName} (${fileSizeKB} KB)\n`;
                text += `--------------------\n`; // Separator
                text += `Magic: ${JSON.stringify(fileHeaderInfo.magic)}\n`;
                text += `Page Size: ${fileHeaderInfo.pageSize} bytes\n`;
                text += `DB Size (Header/Calculated): ${fileHeaderInfo.headerDbSizeInPages} / ${fileHeaderInfo.calculatedDbSizeInPages} pages\n`;
                text += `Read/Write Version: ${fileHeaderInfo.readVersion}/${fileHeaderInfo.writeVersion}\n`;
                text += `Reserved Space Per Page: ${fileHeaderInfo.reservedSpace} bytes\n`;
                text += `File Change Counter: ${fileHeaderInfo.fileChangeCounter}\n`;
                text += `Schema Cookie: ${fileHeaderInfo.schemaCookie}\n`;
                text += `Schema Format: ${fileHeaderInfo.schemaFormat} (${['Legacy','WAL','','Default'][fileHeaderInfo.schemaFormat-1] || 'Unknown'})\n`;
                text += `Text Encoding: ${fileHeaderInfo.textEncoding === 1 ? 'UTF-8' : fileHeaderInfo.textEncoding === 2 ? 'UTF-16le' : fileHeaderInfo.textEncoding === 3 ? 'UTF-16be' : 'Unknown'} (${fileHeaderInfo.textEncoding})\n`;
                text += `User Version: ${fileHeaderInfo.userVersion}\n`;
                text += `SQLite Version Number: ${fileHeaderInfo.sqliteVersionNum} (${Math.floor(fileHeaderInfo.sqliteVersionNum / 1000000)}.${Math.floor((fileHeaderInfo.sqliteVersionNum % 1000000) / 1000)}.${fileHeaderInfo.sqliteVersionNum % 1000})\n`;
                text += `Freelist Trunk/Total(Header)/Total(Traversed): ${fileHeaderInfo.firstFreelistPage} / ${fileHeaderInfo.totalFreelistPages} / ${fileHeaderInfo.traversedFreelistPageCount}\n`;
                text += `Incr-Vacuum Mode: ${fileHeaderInfo.incrementalVacuumMode ? `Yes (Largest Root: ${fileHeaderInfo.largestRootPage})` : 'No'}\n`;
                headerOutput.textContent = text;
             } else if (!headerOutput.textContent.startsWith('Error')) {
                 headerOutput.textContent = "Could not parse header or no file loaded.";
             }
        }

        function renderPageMap() {
             pageMapDiv.innerHTML = '';
             if (!pageData || pageData.length <= 1) {
                 return;
             }
             const fragment = document.createDocumentFragment();
             const actualPages = pageData.filter(p => p.pageNum > 0);
             const totalPages = actualPages.length;
             if (totalPages === 0) {
                 return;
             }
             const containerWidth = pageMapContainer.clientWidth;
             let pageWidth = Math.max(3, Math.floor(containerWidth / totalPages * 0.95));
             pageWidth = Math.min(pageWidth, 60);
             console.log(`Rendering page map: ${totalPages} pages, container ${containerWidth}px, page width ${pageWidth}px`);
             actualPages.forEach(page => {
                 const pageElement = document.createElement('div');
                 pageElement.className = `page page-${page.type.replace(/_/g, '-')}`;
                 pageElement.style.width = `${pageWidth}px`;
                 pageElement.dataset.pageNum = page.pageNum;
                 pageElement.title = `Page ${page.pageNum}: ${page.type}`;
                 if (pageWidth > 20 || totalPages < 100) {
                    pageElement.textContent = page.pageNum;
                    pageElement.style.lineHeight = `${pageMapContainer.clientHeight}px`;
                 } else {
                    pageElement.style.lineHeight = 'normal';
                 }
                 pageElement.addEventListener('click', (e) => {
                     document.querySelectorAll('.page.selected').forEach(el => el.classList.remove('selected'));
                     e.currentTarget.classList.add('selected');
                     showPageDetail(page.pageNum); // Call the specific function
                 });
                 fragment.appendChild(pageElement);
             });
             pageMapDiv.appendChild(fragment);
             pageMapDiv.style.width = `${totalPages * pageWidth}px`;
        }

        function renderLinks() {
             linkOverlay.innerHTML = '';
             const firstPageElement = pageMapDiv.querySelector('.page');
             if (!firstPageElement) {
                 return;
             }
             const pageWidth = parseFloat(firstPageElement.style.width || '3');
             if (pageWidth <= 0 || isNaN(pageWidth) || !pageData) {
                 return;
             }
             const totalPages = pageData.filter(p => p.pageNum > 0).length;
             if (totalPages === 0) {
                 return;
             }
             const totalMapWidth = totalPages * pageWidth;
             linkOverlay.setAttribute('width', totalMapWidth);
             linkOverlay.setAttribute('height', pageMapContainer.clientHeight);
             linkOverlay.setAttribute('viewBox', `0 0 ${totalMapWidth} ${pageMapContainer.clientHeight}`);
             console.log(`Rendering links with page width: ${pageWidth}, total map width: ${totalMapWidth}`);
             pageData.forEach(page => {
                 if (page.links && page.pageNum > 0) {
                    page.links.forEach(link => {
                        if (link.targetPage > 0 && link.targetPage <= totalPages) {
                            drawLink(page.pageNum, link.targetPage, pageWidth, link.type, link.detail);
                        }
                    });
                 }
             });
        }

        function drawLink(sourcePageNum, targetPageNum, pageWidth, linkType, detail = '') {
             const sourceX = (sourcePageNum - 1 + 0.5) * pageWidth;
             const targetX = (targetPageNum - 1 + 0.5) * pageWidth;
             const mapHeight = pageMapContainer.clientHeight;
             let startY = mapHeight * 0.5, endY = mapHeight * 0.5;
             let color = 'rgba(128, 128, 128, 0.6)'; let strokeDash = '';

             if (linkType === 'btree-child') {
                 startY = mapHeight * 0.4; endY = mapHeight * 0.7; color = 'rgba(0, 0, 255, 0.6)';
             } else if (linkType === 'overflow' || linkType === 'overflow-next') {
                 startY = mapHeight * 0.2; endY = mapHeight * 0.8; color = 'rgba(255, 165, 0, 0.7)';
                 if (linkType === 'overflow-next') {
                     strokeDash = '4, 2';
                 }
             } else if (linkType === 'freelist-next-trunk') {
                 startY = mapHeight * 0.1; endY = mapHeight * 0.1; color = 'rgba(218, 165, 32, 0.8)';
             } else if (linkType === 'freelist-leaf-ptr') {
                 startY = mapHeight * 0.15; endY = mapHeight * 0.9; color = 'rgba(173, 216, 230, 0.7)';
             }

             const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
             line.setAttribute('x1', sourceX);
             line.setAttribute('y1', startY);
             line.setAttribute('x2', targetX);
             line.setAttribute('y2', endY);
             line.style.stroke = color;
             line.style.strokeWidth = '1.5';
             if (strokeDash) {
                 line.style.strokeDasharray = strokeDash;
             }
             const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
             title.textContent = `Link: ${linkType} from ${sourcePageNum} to ${targetPageNum} ${detail ? '('+detail+')' : ''}`;
             line.appendChild(title);
             linkOverlay.appendChild(line);
        }

        // --- Show Page Detail in Dialog ---
        function showPageDetail(pageNum) {
            const page = pageData.find(p => p.pageNum === pageNum);
            if (!page || !fileBuffer) {
                pageDetailTitle.textContent = `Error`; // Use correct title ID
                pageDetailContent.innerHTML = `<p>Details for page ${pageNum} not found or file buffer missing.</p>`;
                showPageDetailDialog();
                return;
            }

            const dataView = new DataView(fileBuffer);
            let detailHtml = ""; // Build HTML string directly

            // --- Page Summary Section ---
            detailHtml += `<h3>Page ${page.pageNum} Summary</h3>`;
            detailHtml += `<dl>`; // Start definition list
            detailHtml += `<dt>Page Type</dt><dd>${page.type}</dd>`;
            detailHtml += `<dt>File Offset</dt><dd>${page.rawOffset} (0x${page.rawOffset.toString(16)})</dd>`;
            const headerSize = page.pageHeaderSize || 0;
            detailHtml += `<dt>Page Header Size</dt><dd>${headerSize} bytes</dd>`;
            detailHtml += `</dl>`;

            // --- Space Usage Section ---
            detailHtml += `<h3>Space Usage</h3>`;
            if (page.type !== 'unknown' && page.type !== 'freelist-trunk' && page.type !== 'freelist-leaf' && page.type !== 'overflow') {
                 const cellPointerArraySize = (page.header?.cellCount || 0) * 2;
                 const fileHeaderOnPage1 = (page.pageNum === 1 ? 100 : 0);
                 const totalHeaderAreaSize = fileHeaderOnPage1 + headerSize + cellPointerArraySize;
                 let usedCellSpace = 0; let invalidOffsets = 0;
                 (page.cellOffsets || []).forEach((offset, index) => {
                     if (offset === 0) { invalidOffsets++; return; }
                     let nextOffset = pageSize;
                     for(let nextIdx = index + 1; nextIdx < page.cellOffsets.length; nextIdx++) { if (page.cellOffsets[nextIdx] > 0) { nextOffset = page.cellOffsets[nextIdx]; break; } }
                     if (offset > 0 && offset < pageSize) { if (nextOffset > offset) { usedCellSpace += (Math.min(nextOffset, pageSize) - offset); } else { usedCellSpace += (pageSize - offset); console.warn(`Page ${pageNum} Cell ${index}: Unusual size calc`); } } else { console.warn(`Page ${pageNum} Cell ${index}: Offset ${offset} invalid`); }
                 });
                 const cellContentStart = page.header?.cellContentStartOffset || 0;
                 const freeBeforeContent = (cellContentStart >= totalHeaderAreaSize && cellContentStart <= pageSize) ? cellContentStart - totalHeaderAreaSize : 0;
                 const totalUsedApprox = totalHeaderAreaSize + usedCellSpace;
                 const estimatedFreeTotal = pageSize - totalUsedApprox;

                 detailHtml += `<dl>`;
                 detailHtml += `<dt>File Header (Pg 1)</dt><dd>${fileHeaderOnPage1} bytes</dd>`;
                 detailHtml += `<dt>Page Header</dt><dd>${headerSize} bytes</dd>`;
                 detailHtml += `<dt>Cell Pointer Array</dt><dd>${cellPointerArraySize} bytes (${page.header?.cellCount || 0} pointers)</dd>`;
                 detailHtml += `<dt>Total Header Area</dt><dd>${totalHeaderAreaSize} bytes</dd>`;
                 detailHtml += `<dt>Cell Content Start Offset</dt><dd>${cellContentStart}</dd>`;
                 detailHtml += `<dt>Free Before Content</dt><dd>${freeBeforeContent} bytes</dd>`;
                 detailHtml += `<dt>Fragmented Bytes (Header)</dt><dd>${page.header?.fragmentedFreeBytes || 0}</dd>`;
                 detailHtml += `<dt>~ Used Cell Content</dt><dd>${usedCellSpace} bytes (${invalidOffsets} invalid offsets ignored)</dd>`;
                 detailHtml += `<dt>~ Total Used (Header+Cells)</dt><dd>${totalUsedApprox} bytes</dd>`;
                 detailHtml += `<dt>~ Total Free (PageSz - Used)</dt><dd>${estimatedFreeTotal} bytes (~${((estimatedFreeTotal/pageSize)*100).toFixed(1)}%)</dd>`;
                 detailHtml += `</dl>`;
            } else {
                detailHtml += `<p>(Not calculated for type: ${page.type})</p>`;
            }

            // --- Parsed Header Section ---
            detailHtml += `<h3>Parsed Page Header Fields</h3>`;
            if (page.header && Object.keys(page.header).length > 0) {
                detailHtml += `<dl>`;
                for (const key in page.header) {
                     let value = page.header[key];
                     if (typeof value === 'object' && value !== null) value = JSON.stringify(value);
                     else if (value === undefined) value = 'undefined';
                     const safeKey = key.replace(/</g, "<").replace(/>/g, ">");
                     const safeValue = String(value).replace(/</g, "<").replace(/>/g, ">");
                     detailHtml += `<dt>${safeKey}</dt><dd>${safeValue}</dd>`;
                }
                 detailHtml += `</dl>`;
            } else {
                 detailHtml += `<p>(No header fields parsed or applicable)</p>`;
            }

            // --- Links Section ---
            detailHtml += `<h3>Links Originating From This Page</h3>`;
            const linksJson = (page.links && page.links.length > 0) ? JSON.stringify(page.links, null, 2) : '(None identified)';
            const safeLinksJson = linksJson.replace(/</g, "<").replace(/>/g, ">");
            detailHtml += `<pre>${safeLinksJson}</pre>`;

            // --- Cell Summaries Section ---
            detailHtml += `<h3>Cell Summaries (${page.cellOffsets?.length || 0} cells)</h3>`;
            if (page.cellOffsets && page.cellOffsets.length > 0) {
                 const validOffsets = page.cellOffsets.filter(offset => offset > 0);
                 if (validOffsets.length !== page.cellOffsets.length) {
                     detailHtml += `<p><em>(${page.cellOffsets.length - validOffsets.length} invalid cell offsets omitted)</em></p>`;
                 }
                 if (validOffsets.length > 0) {
                     validOffsets.forEach((offset, index) => {
                         const cellOutput = parseCellSummary(dataView, page.rawOffset, offset, page.type, pageSize, page.pageNum, index);
                         const safeSummaryText = cellOutput.summaryText.replace(/</g, "<").replace(/>/g, ">");
                         detailHtml += `<div class="cell-detail-item">`;
                         detailHtml += `<p>${safeSummaryText}</p>`;
                         detailHtml += cellOutput.dumpHtml;
                         detailHtml += `</div>`;
                     });
                 } else {
                     detailHtml += `<p>(No valid cell offsets found)</p>`;
                 }
            } else if (page.header?.cellCount > 0) {
                detailHtml += `<p>(Header reports ${page.header.cellCount} cells, but offsets could not be parsed/stored)</p>`;
            } else {
                detailHtml += `<p>(No cells applicable or reported for this page type)</p>`;
            }

            // Update Page Detail Dialog
            pageDetailTitle.textContent = `Page ${page.pageNum} Details (${page.type})`; // Use correct ID
            pageDetailContent.innerHTML = detailHtml; // Use correct ID
            pageDetailContent.scrollTop = 0;
            showPageDetailDialog(); // Show the correct dialog
            renderLinks();

        } // End showPageDetail

    </script>

</body>
</html>